{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Linux Notes","text":"<p>Personal notes on the Linux Operating System</p>"},{"location":"containers/cgroups.html","title":"Linux Control Groups v2 (<code>cgroups</code>)","text":"<ul> <li> <p>allow to implement metering and limiting on the resources used by processes</p> </li> <li> <p>each subsystem has a hierarchy: separate hierarchies for CPU, memory, block I/O, ...</p> </li> <li>hierarchies are independent (the trees for memory, cpu can be different)</li> <li>each process is in a \"node\" in each hierarchy</li> <li>each hierarchy starts with 1 node (the root)</li> <li>each node is a group of processes sharing the same resources</li> </ul> <p><code>cgroups</code> are a mechanism to organize processes hierarchically and distribute system resources along the hierarchy in a controlled and configurable manner.</p> <p><code>cgroups</code> are largely composed of two parts: the core and the controllers.</p> <p>The cgroup core is primarily responsible for hierarchically organizing processes.  A cgroup controller is usually responsible for distributing a specific type of system resource along the hierarchy although there are utility controllers which serve purposes other than resource distribution. </p> <p>cgroups form a tree structure and every process in the system belongs to one and only one cgroup. All threads of a process belong to the same cgroup.</p> <p>On creation, all processes are put in the cgroup that the parent process belongs to at the time. A process can be migrated to another cgroup. Migration of a process doesn't affect already existing descendant processes.</p> <p>Following certain structural constraints, controllers may be enabled or disabled selectively on a cgroup. All controller behaviors are hierarchical - if a controller is enabled on a cgroup, it affects all processes which belong to the cgroups consisting the inclusive sub-hierarchy of the cgroup. When a controller is enabled on a nested cgroup, it always restricts the resource distribution further. The restrictions set closer to the root in the hierarchy can not be overridden from further away.</p>"},{"location":"containers/cgroups.html#mounting","title":"Mounting","text":"<p>Unlike v1, cgroups v2 has a single hierarchy that can be mounted with:</p> Bash<pre><code>mount -t cgroup2 none &lt;mount-point&gt;\n</code></pre> <p>Note: The cgroup filesystem has the magic number <code>0x63677270</code> (\"cgrp\")</p> <p>All controllers which support v2 and are not bound to a v1 hierarchy are automatically bound to the v2 hierarchy and show up at the root. Controllers which are not in active use in the v2 hierarchy can be bound to other hierarchies. This allows mixing v2 hierarchy with the legacy v1 multiple hierarchies in a fully backward compatible way.</p>"},{"location":"filesystem/file-links.html","title":"Symlink, Hardlink, Reflink","text":"<p>Unix files consist of two parts: the data part and the filename part. The data part is associated with something called an inode. The inode carries the map of where the data is, the file permissions, etc. for the data.</p> Text Only<pre><code>                                           +------+ +------+\n                         .---------------&gt; | data | | data | etc\n                        /                  +------+ +------+\n+--------------------------------+\n| permbits, etc | data addresses |\n+--------------inode-------------+\n</code></pre> <p>The filename part carries a name and an associated inode number.</p> Text Only<pre><code>                                  +---------------------------+\n                 .--------------&gt; | permbits, etc | addresses |\n                /                 +-----------inode-----------+\n+--------------------+\n| filename | inode # |\n+--------------------+\n</code></pre>"},{"location":"filesystem/file-links.html#hardlinks","title":"Hardlinks","text":"<p>More than one filename can reference the same inode number. These files are said to be hard linked together.</p> Text Only<pre><code>+--------------------+\n| filename | inode # |\n+--------------------+\n                \\                 +---------------------------+\n                 &gt;--------------&gt; | permbits, etc | addresses |\n                /                 +------------inode----------+\n+---------------------+\n| othername | inode # |\n+---------------------+\n</code></pre>"},{"location":"filesystem/file-links.html#symlinks-aka-softlinks","title":"Symlinks (aka Softlinks)","text":"<p>Symlinks are a special file type whose data part carries a path to another file. Since it is a special file, the OS recognizes the data as a path, and redirects opens, reads, and writes so that, instead of accessing the data within the special file, they access the data in the file named by the data in the special file.</p> Text Only<pre><code>+--------------------+\n| filename | inode # |\n+--------------------+\n              \\\n               \\     +---------------------------+\n                '--&gt; | permbits, etc | addresses |\n                     +-----------inode-----------+\n                                     /\n                                    /\n                                   /\n .--------------------------------'\n(     +--------------------------+\n '--&gt; |\"/path/to/some/other/file\"| \n      +----------data------------+\n                  /                     |\n .~ ~ ~ ~ ~ ~ ~ ~'                      |-- (redirected at open() time)\n(     +--------------------+            |\n '~~&gt; | filename | inode # |\n      +--------------------+\n                   \\               +---------------------------+\n                    '------------&gt; | permbits, etc | addresses |\n                                   +-----------inode-----------+\n                                                /\n                                               /\n .--------------------------------------------'\n(     +------+  +------+ \n '--&gt; | data |  | data | etc.\n      +------+  +------+ \n</code></pre> <p>Now, the filename part of the file is stored in a special file of its own along with the filename parts of other files; this special file is called a directory.</p>"},{"location":"filesystem/file-links.html#reflink","title":"Reflink","text":"<p>A Reflink is a type of shallow copy of file data that shares the blocks but otherwise the files are independent and any change to the file will not affect the other. This builds on the underlying copy-on-write mechanism. A reflink will effectively create only a separate metadata pointing to the shared blocks which is typically much faster than a deep copy of all blocks.</p> Text Only<pre><code>+--------------------+\n| filename | inode # |\n+--------------------+\n            \\        +---------------------------+\n             '-----&gt; | permbits, etc | addresses |\n                     +-----------inode-----------+\n                                   \\                +------+  +------+\n                                    &gt;-------------&gt; | data |  | data | etc.\n                                   /                +------+  +------+\n                     +---------------------------+\n             .-----&gt; | permbits, etc | addresses |\n            /        +-----------inode-----------+\n+---------------------+\n| othername | inode # |\n+---------------------+\n</code></pre> <p>There are some constraints:</p> <ul> <li>cross-filesystem reflink is not possible, there\u2019s nothing in common between so the block sharing can\u2019t work</li> <li>reflink crossing two mount points of the same filesystem support depends on kernel version</li> </ul>"},{"location":"filesystem/file-links.html#directories","title":"Directories","text":"<p>The directory, as a file, is just an array of filename parts of other files.</p> <p>When a directory is built, it is initially populated with the filename parts of two special files: the <code>.</code> and <code>..</code> files.</p> <p>The filename part for the <code>.</code> file is populated with the <code>inode</code> of the directory file in which the entry has been made: <code>.</code> is a hardlink to the file that implements the current directory.</p> <p>The filename part for the <code>..</code> file is populated with the <code>inode</code> of the directory file that contains the filename part of the current directory file: <code>..</code> is a hardlink to the file that implements the immediate parent of the current directory.</p> <p>The <code>ln</code> command knows how to build hardlinks and softlinks; the <code>mkdir</code> command knows how to build directories (the OS takes care of the above hardlinks).</p> <p>There are restrictions on what can be hardlinked (both links must reside on the same filesystem, the source file must exist, etc.) that are not applicable to softlinks (source and target can be on separate file systems, source does not have to exist, etc.).</p>"},{"location":"filesystem/procfs.html","title":"<code>/proc</code> Filesystem","text":"<p>The proc file system contains a hierarchy of special files that represent the current state of the kernel.</p> <p>Files in the <code>/proc</code> directory contain information about the hardware and current processes running on the system. Files that have write permission can be modified to change the configuration of the kernel.</p>"},{"location":"filesystem/procfs.html#top-level-files-within-proc","title":"Top-Level Files Within <code>/proc</code>","text":"<ul> <li> <p><code>/proc/buddyinfo</code>: This file is used primarily for diagnosing memory fragmentation issues.</p> </li> <li> <p><code>/proc/cmdline</code>: This file shows the parameters passed to the kernel at the time it is started.</p> </li> <li> <p><code>/proc/cpuinfo</code>: This virtual file identifies the type of processor used by the system.</p> </li> <li> <p><code>/proc/crypto</code>: This file lists all installed cryptographic ciphers used by the Linux kernel, including additional details for each.</p> </li> <li> <p><code>/proc/devices</code>: This file displays the various character and block devices currently configured (not including devices whose modules are not loaded).</p> </li> <li> <p><code>/proc/dma</code>: This file contains a list of the registered ISA DMA channels in use.</p> </li> <li> <p><code>/proc/execdomains</code>: This file lists the execution domains currently supported by the Linux kernel, along with the   range of personalities they support.</p> </li> <li> <p><code>/proc/filesystems</code>: This file displays a list of the file system types currently supported by the kernel.   The first column signifies whether the file system is mounted on a block device. Those beginning with <code>nodev</code> are not mounted on a device.   The second column lists the names of the file systems supported.   The mount command cycles through the file systems listed here when one is not specified as an argument.</p> </li> <li> <p><code>/proc/interrupts</code>: This file records the number of interrupts per IRQ on the <code>x86</code> architecture.</p> </li> <li> <p><code>/proc/iomem</code>: This file shows the current map of the system\u2019s memory for each physical device.</p> </li> <li> <p><code>/proc/ioports</code>: This file provides a list of currently registered port regions used for input or output communication with a device.</p> </li> <li> <p><code>/proc/kcore</code>: This file represents the physical memory of the system and is stored in the core file format.   The contents of this file are designed to be examined by a debugger, such as gdb, and is not human readable.</p> </li> <li> <p><code>/proc/kmsg</code>: This file is used to hold messages generated by the kernel. These messages are then picked up by other   programs, such as <code>/bin/dmesg</code>.</p> </li> <li> <p><code>/proc/loadavg</code>: This file provides a look at the load average in regard to both the CPU and I/O over time, as well as   additional data used by uptime and other commands.</p> </li> <li> <p><code>/proc/locks</code>: This file displays the files currently locked by the kernel. The contents of this file contain internal   kernel debugging data and can vary tremendously, depending on the use of the system.</p> </li> <li> <p><code>/proc/mdstat</code>: This file contains the current information for multiple-disk, RAID configurations.</p> </li> <li> <p><code>/proc/meminfo</code>: This file reports a large amount of valuable information about the system\u2019s RAM usage.</p> </li> <li> <p><code>/proc/modules</code>: This file displays a list of all modules loaded into the kernel. Most of this information can also be   viewed by using the /sbin/lsmod command.</p> </li> </ul>"},{"location":"filesystem/procfs.html#process-directories-in-proc","title":"Process Directories in <code>/proc</code>","text":"<p>The <code>/proc</code> directory contains directories with numerical names. These directories are named after a program\u2019s process ID and contain information about that process. The owner and group of each process directory are set to the user running the process.</p> <p>Each <code>/proc/&lt;pid&gt;</code> directory contains several files including:</p> <ul> <li><code>cmdline</code>: The command issued when starting the process</li> <li><code>cwd</code>: A symbolic link to the current working directory for the process</li> <li><code>environ</code>: A list of the environment variables for the process</li> <li><code>exe</code>: A symbolic link to the executable of this process</li> <li><code>fd</code>: The directory containing all of the file descriptors for a particular process</li> <li><code>maps</code>: A list of memory maps to executables and library files associated with process</li> <li><code>mem</code>: The memory held by the process (the file cannot be read by the user)</li> <li><code>root</code>: A link to the root directory of the process</li> <li><code>stat</code>: The status of the process including run state and memory usage</li> <li><code>statm</code>: The status of the memory in use by the process</li> <li><code>status</code>: The status of the process in a more readable form than stat or statm</li> </ul>"},{"location":"filesystem/procfs.html#other-directories-in-proc","title":"Other Directories in <code>/proc</code>","text":"<p>Other directories within the <code>/proc</code> directory group similar information by topic. The following is a partial list of these directories:</p> <ul> <li> <p><code>/proc/bus</code>: This directory contains information about the various buses available on the system.   The subdirectories and files available within /proc/bus vary depending on the devices connected to the system.</p> </li> <li> <p><code>/proc/bus/pci</code>, <code>/proc/bus/usb</code>: It's possible to get a list of all PCI and USB devices present on the system by using   the cat command on the devices file within these directories, but the output is difficult to read and interpret.   For a human-readable list of devices, run the <code>lspci</code> and <code>lsusb</code> commands.</p> </li> <li> <p><code>/proc/driver</code>: This directory contains information for specific drivers in use by the kernel.</p> </li> <li> <p><code>/proc/fs</code>: This directory shows which file systems are exported.</p> </li> <li> <p><code>/proc/irq</code>: This directory is used to set IRQ to CPU affinity, which allows the system to connect a particular IRQ to only one CPU.   Alternatively, it can exclude a CPU from handling any IRQs.</p> </li> <li> <p><code>/proc/self/net</code>: This directory provides a comprehensive look at various networking parameters and statistics.   Each directory and virtual file within this directory describes aspects of the system\u2019s network configuration.   The <code>/proc/net</code> file is a symbolic link to this directory.</p> </li> <li> <p><code>/proc/scsi</code>: The primary file in this directory is <code>/proc/scsi/scsi</code>, which contains a list of every recognized SCSI device.   From this listing, the type of device, as well as the model name, vendor, SCSI channel, and ID data is available.</p> </li> <li> <p><code>/proc/sys</code>: This directory is different from others in <code>/proc</code>, because it not only provides information about the system   but also allows to immediately enable and disable kernel features.   Changes made by writing to the files are not persistent and disappear when the system is restarted.   To make changes persist after rebooting, add them to the <code>/etc/sysctl.conf</code> file.</p> </li> <li> <p><code>/proc/sys/dev</code>: This directory provides parameters for particular devices on the system.</p> </li> <li> <p><code>/proc/sys/fs</code>: This directory contains options and information concerning various aspects of the file system, including quota, file handle, and inode information.</p> </li> <li> <p><code>/proc/sys/kernel</code>: This directory contains a variety of different configuration files that directly affect the operation of the kernel.</p> </li> <li> <p><code>/proc/sys/net</code>: This directory contains subdirectories concerning various networking topics.   Ir's possible to alter the files within these directories to adjust the network configuration on a running system.</p> </li> <li> <p><code>/proc/sysvipc</code>: This directory contains information about System V Interprocess Communication (IPC) resources.   The files in this directory relate to System V IPC calls for messages (msg), semaphores (sem), and shared memory (shm).</p> </li> <li> <p><code>/proc/tty</code>: This directory contains information about the available and currently used tty devices on the system.   The drivers file is a list of the current tty devices in use.</p> </li> </ul>"},{"location":"filesystem/sysfs.html","title":"<code>/sys</code> Filesystem (<code>sysfs</code>)","text":""},{"location":"filesystem/sysfs.html#sysfs-directories","title":"<code>sysfs</code> Directories","text":"<p>In addition to <code>/proc</code>, the kernel also exports information to another virtual file system called <code>sysfs</code>. <code>sysfs</code> is used by programs such as <code>udev</code> to access device and device driver information.</p>"},{"location":"filesystem/sysfs.html#sysblock","title":"<code>/sys/block</code>","text":"<p>This directory contains entries for each block device in the system. Symbolic links point to the physical device that the device maps to in the physical device tree.</p> <p>For example, attributes for the sda disks reside in the <code>/sys/block/sda</code> directory.</p>"},{"location":"filesystem/sysfs.html#sysbus","title":"<code>/sys/bus</code>","text":"<p>This directory contains subdirectories for each physical bus type supported in the kernel. Each bus type has two subdirectories: devices and drivers.  </p> <p>The devices directory lists devices discovered on that type of bus. The drivers directory contains directories for each device driver registered with the bus type. Driver parameters can be viewed and manipulated.</p>"},{"location":"filesystem/sysfs.html#sysclass","title":"<code>/sys/class</code>","text":"<p>This directory contains every device class registered with the kernel. Device classes describe a functional type of device. Examples include input devices, network devices, and block devices.</p>"},{"location":"filesystem/sysfs.html#sysdevices","title":"<code>/sys/devices</code>","text":"<p>This directory contains the global device hierarchy of all devices on the system. This directory also contains a platform directory and a system directory. </p> <p>The platform directory contains peripheral devices specific to a particular platform such as device controllers. The system directory contains non-peripheral devices such as CPUs and APICs.</p>"},{"location":"filesystem/sysfs.html#sysfirmware","title":"<code>/sys/firmware</code>","text":"<p>This directory contains subdirectories with firmware objects and attributes.</p>"},{"location":"filesystem/sysfs.html#sysmodule","title":"<code>/sys/module</code>","text":"<p>This directory contains subdirectories for each module that is loaded into the kernel.</p>"},{"location":"filesystem/sysfs.html#syspower","title":"<code>/sys/power</code>","text":"<p>The system power state can be controlled from this directory. The disk attribute controls the method by which the system suspends to disk. The state attribute allows a process to enter a low power state.</p>"},{"location":"init/open-rc.html","title":"OpenRC","text":"<p>OpenRC is a dependency-based init system for Unix-like systems that maintains compatibility with the system-provided init system, normally located in /sbin/init. OpenRC is Gentoo's native init system, although other init systems are available.</p> <p>OpenRC will start necessary system services in the correct order at boot, manage them while the system is in use, and stop them at shutdown. It can manage daemons installed from the Gentoo repository, can optionally supervise the processes it launches, and has an the possibility to start processes in parallel - when possible - to shorten boot time.</p>"},{"location":"init/open-rc.html#runlevels-services","title":"Runlevels &amp; Services","text":"<p>OpenRC has a concept of runlevels. A runlevel is a collection of services that needs to be started. Instead of random numbers they are named, and users can create their own if needed.</p> <p>The <code>rc-status</code> helper will print all currently active runlevels and the state of services in them:</p> Bash<pre><code>Runlevel: default\n  modules                     [  started  ]\n  lvm                         [  started  ]\n</code></pre> <p>All runlevels are represented as folders in <code>/etc/runlevels/</code> with symlinks to the actual service scripts.</p> <p>Calling <code>openrc</code> with an argument will switch to that runlevel; this will start and stop services as needed.</p>"},{"location":"init/open-rc.html#managing-runlevels","title":"Managing Runlevels","text":"<p>Managing runlevels is usually done through the <code>rc-update</code> helper, but could of course be done by hand if desired.</p> Bash<pre><code>rc-update add &lt;service&gt; &lt;runlevel&gt;\nrc-update del &lt;service&gt; &lt;runlevel&gt;\nrc-update show &lt;runlevel&gt;\n</code></pre> <p>The default startup uses the runlevels <code>sysinit</code>, <code>boot</code>, and <code>default</code>, in that order. Shutdown uses the <code>shutdown</code> runlevel.</p>"},{"location":"init/open-rc.html#managing-services","title":"Managing Services","text":"<p>Any service can, at any time, be started/stopped/restarted by executing with the <code>rc-service</code> helper  someservice start, rc-service someservice stop, etc.</p> Bash<pre><code>rc-service &lt;service&gt; start\nrc-service &lt;service&gt; stop\nrc-service &lt;service&gt; restart\nrc-service &lt;service&gt; status\nrc-service &lt;service&gt; zap\n</code></pre> <p>Another, less preferred method, is to run the service script directly, e.g. /etc/init.d/service start, /etc/init.d/service stop, etc.</p> Bash<pre><code>/etc/init.d/&lt;service&gt; start\n/etc/init.d/&lt;service&gt; stop\n/etc/init.d/&lt;service&gt; restart\n/etc/init.d/&lt;service&gt; status\n/etc/init.d/&lt;service&gt; zap\n</code></pre> <p>There is a special command <code>zap</code> that makes OpenRC 'forget' that a service is started. This is mostly useful to reset a crashed service to stopped state without invoking the (possibly broken) stop function of the service script.</p> <p>Calling <code>openrc</code> without any arguments will try to reset all services so that the current runlevel is satisfied.</p>"},{"location":"init/systemd.html","title":"Systemd","text":"<p>systemd is a suite of basic building blocks for a Linux system. It provides a system and service manager that runs as PID 1 and starts the rest of the system.</p> <p><code>systemd</code> provides aggressive parallelization capabilities, uses socket and D-Bus activation for starting services, offers on-demand starting of daemons, keeps track of processes using Linux control groups, maintains mount and automount points, and implements an elaborate transactional dependency-based service control logic.</p>"}]}